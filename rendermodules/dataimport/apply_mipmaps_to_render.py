if __name__=="__main__" and __package__ is None:
    __package__="rendermodules.dataimport.apply_mipmaps_to_render"


import json
import os
import sys
import renderapi
from ..module.render_module import RenderModule, RenderParameters
from argschema.fields import InputFile, InputDir
import argschema
import marshmallow as mm
from marshmallow import ValidationError, validates_schema
import multiprocessing as mp
from functools import partial
import urllib
import urlparse
import glob
import time
import tempfile

example = {
    "render":{
        "host":"em-131fs",
        "port":8998,
        "owner":"gayathri",
        "project":"MM2",
        "client_scripts":"/allen/programs/celltypes/workgroups/em-connectomics/gayathrim/nc-em2/Janelia_Pipeline/render_20170613/render-ws-java-client/src/main/scripts"
    },
    "input_stack":"mm2_acquire_8bit",
    "output_stack":"mm2_mipmap_test",
    "mipmap_dir":"/net/aidc-isi1-prd/scratch/aibs/scratch",
    "imgformat":"tif",
    "levels":6,
    "zstart":1015,
    "zend":1015
}


def addMipMapsToRender(render, input_stack, mipmap_dir, imgformat, levels, z):
    tilespecPaths = []

    tilespecs = render.run(renderapi.tilespec.get_tile_specs_from_z, input_stack, z)

    print z
    for ts in tilespecs:
        mm1 = ts.ip.mipMapLevels[0]

        oldUrl = mm1.imageUrl
        filepath = urllib.unquote(urlparse.urlparse(str(oldUrl).path))
        #filepath = str(oldUrl).lstrip('file:/')
        #filepath = filepath.replace("%20", " ")

        # assumes that the mipmaps are stored in the way generated by the render's mipmap client
        # which adds the file extension in addition to the existing file extension from mipmap level 0
        if imgformat is "png":
            imgf = ".png"
        elif imgformat is "jpg":
            imgf = ".jpg"
        else:
            imgf = ".tif"

        for i in range(1,levels+1):
            scUrl = 'file:' + os.path.join(mipmap_dir, str(i), filepath) + imgf
            print scUrl
            mm1 = renderapi.tilespec.MipMapLevel(level=i, imageUrl=scUrl)
            ts.ip.update(mm1)

        tempjson = tempfile.NamedTemporaryFile(suffix=".json", mode='r', delete=False)
        tempjson.close()
        tsjson = tempjson.name

        with open(tsjson, 'w') as f:
            renderapi.utils.renderdump(tilespecs, f)
        f.close()
        tilespecPaths.append(tsjson)

    return tilespecPaths


class AddMipMapsToStackParameters(RenderParameters):
    input_stack = mm.fields.Str(required=True,
        metadata={'description':'stack for which the mipmaps are to be generated'})
    output_stack = mm.fields.Str(required=False,default=input_stack,
        metadata={'description':'the output stack name. Leave to overwrite input stack'})
    mipmap_dir = InputDir(required=True,
        metadata={'description':'directory to which the mipmaps will be stored'})
    levels = mm.fields.Int(required=False,default=6,
        metadata={'description':'number of levels of mipmaps, default is 6'})
    zstart = mm.fields.Int(required=False,
        metadata={'description':'start z-index in the stack'})
    zend = mm.fields.Int(required=False,
        metadata={'description':'end z-index in the stack'})
    z = mm.fields.Int(required=False,
        metadata={'description':'z-index of section in the stack'})
    imgformat = mm.fields.Str(required=False, default="tiff",
        metadata={'description':'mipmap image format, default is tiff'})
    pool_size = mm.fields.Int(required=False, default=20,
        metadata={'description':'number of cores to be used'})

    @validates_schema
    def validate_zvalues(self, data):
        if 'zstart' not in data.keys() or 'zend' not in data.keys():
            if 'zvalue' not in data.keys():
                raise ValidationError('Need a z value')
        if 'zvalue' not in data.keys():
            if 'zstart' not in data.keys() or 'zend' not in data.keys():
                raise ValidationError('Need a z range')


class AddMipMapsToStack(RenderModule):
    def __init__(self, schema_type=None, *args, **kwargs):
        if schema_type is None:
            schema_type = AddMipMapsToStackParameters
        super(AddMipMapsToStack,self).__init__(schema_type=schema_type, *args, **kwargs)

    def run(self):
        self.logger.debug('Applying mipmaps to stack')

        # get the list of z indices
        zvalues = self.render.run(renderapi.stack.get_z_values_for_stack, self.args['input_stack'])

        try:
            self.args['zstart'] and self.args['zend']
            zvalues1 = range(self.args['zstart'], self.args['zend']+1)
            zvalues = list(set(zvalues1).intersection(set(zvalues))) # extract only those z's that exist in the input stack
        except NameError:
            try:
                self.args['z']
                if self.args['z'] in zvalues:
                    zvalues = [self.args['z']]
            except NameError:
                self.logger.error('No z value given for mipmap generation')

        if len(zvalues) == 0:
            self.logger.error('No sections found for stack {}'.format(self.args['input_stack']))

        print zvalues
        mypartial = partial(addMipMapsToRender, self.render, self.args['input_stack'], self.args['mipmap_dir'], self.args['imgformat'], self.args['levels'])
        with renderapi.client.WithPool(self.args['pool_size']) as pool:
            tilespecPaths = pool.map(mypartial, zvalues)

        # add the tile spec to render stack
        try:
            self.args['output_stack']
        except NameError:
            self.logger.error("Need an output stack name for adding mipmaps")

        if self.args['output_stack'] not in self.render.run(renderapi.render.get_stacks_by_owner_project):
            # stack does not exist
            self.render.run(renderapi.stack.create_stack, output_stack)

        self.render.run(renderapi.stack.set_stack_state, self.args['output_stack'], 'LOADING')
        self.render.run(renderapi.client.import_jsonfiles_parallel, self.args['output_stack'], tilespecPaths)
        self.render.run(renderapi.stack.set_stack_state, self.args['output_stack'], 'COMPLETE')


if __name__=="__main__":
    #mod = AddMipMapsToStack(input_data=example)
    mod = AddMipMapsToStack(schema_type=AddMipMapsToStackParameters)
    mod.run()
